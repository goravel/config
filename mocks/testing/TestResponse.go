// Code generated by mockery. DO NOT EDIT.

package testing

import (
	http "net/http"

	testing "github.com/goravel/framework/contracts/testing"
	mock "github.com/stretchr/testify/mock"
)

// TestResponse is an autogenerated mock type for the TestResponse type
type TestResponse struct {
	mock.Mock
}

type TestResponse_Expecter struct {
	mock *mock.Mock
}

func (_m *TestResponse) EXPECT() *TestResponse_Expecter {
	return &TestResponse_Expecter{mock: &_m.Mock}
}

// AssertAccepted provides a mock function with given fields:
func (_m *TestResponse) AssertAccepted() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertAccepted")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertAccepted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertAccepted'
type TestResponse_AssertAccepted_Call struct {
	*mock.Call
}

// AssertAccepted is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertAccepted() *TestResponse_AssertAccepted_Call {
	return &TestResponse_AssertAccepted_Call{Call: _e.mock.On("AssertAccepted")}
}

func (_c *TestResponse_AssertAccepted_Call) Run(run func()) *TestResponse_AssertAccepted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertAccepted_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertAccepted_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertAccepted_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertAccepted_Call {
	_c.Call.Return(run)
	return _c
}

// AssertBadRequest provides a mock function with given fields:
func (_m *TestResponse) AssertBadRequest() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertBadRequest")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertBadRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertBadRequest'
type TestResponse_AssertBadRequest_Call struct {
	*mock.Call
}

// AssertBadRequest is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertBadRequest() *TestResponse_AssertBadRequest_Call {
	return &TestResponse_AssertBadRequest_Call{Call: _e.mock.On("AssertBadRequest")}
}

func (_c *TestResponse_AssertBadRequest_Call) Run(run func()) *TestResponse_AssertBadRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertBadRequest_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertBadRequest_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertBadRequest_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertBadRequest_Call {
	_c.Call.Return(run)
	return _c
}

// AssertConflict provides a mock function with given fields:
func (_m *TestResponse) AssertConflict() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertConflict")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertConflict_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertConflict'
type TestResponse_AssertConflict_Call struct {
	*mock.Call
}

// AssertConflict is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertConflict() *TestResponse_AssertConflict_Call {
	return &TestResponse_AssertConflict_Call{Call: _e.mock.On("AssertConflict")}
}

func (_c *TestResponse_AssertConflict_Call) Run(run func()) *TestResponse_AssertConflict_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertConflict_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertConflict_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertConflict_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertConflict_Call {
	_c.Call.Return(run)
	return _c
}

// AssertCookie provides a mock function with given fields: name, value
func (_m *TestResponse) AssertCookie(name string, value string) testing.TestResponse {
	ret := _m.Called(name, value)

	if len(ret) == 0 {
		panic("no return value specified for AssertCookie")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(string, string) testing.TestResponse); ok {
		r0 = rf(name, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertCookie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertCookie'
type TestResponse_AssertCookie_Call struct {
	*mock.Call
}

// AssertCookie is a helper method to define mock.On call
//   - name string
//   - value string
func (_e *TestResponse_Expecter) AssertCookie(name interface{}, value interface{}) *TestResponse_AssertCookie_Call {
	return &TestResponse_AssertCookie_Call{Call: _e.mock.On("AssertCookie", name, value)}
}

func (_c *TestResponse_AssertCookie_Call) Run(run func(name string, value string)) *TestResponse_AssertCookie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *TestResponse_AssertCookie_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertCookie_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertCookie_Call) RunAndReturn(run func(string, string) testing.TestResponse) *TestResponse_AssertCookie_Call {
	_c.Call.Return(run)
	return _c
}

// AssertCookieExpired provides a mock function with given fields: _a0
func (_m *TestResponse) AssertCookieExpired(_a0 string) testing.TestResponse {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertCookieExpired")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(string) testing.TestResponse); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertCookieExpired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertCookieExpired'
type TestResponse_AssertCookieExpired_Call struct {
	*mock.Call
}

// AssertCookieExpired is a helper method to define mock.On call
//   - _a0 string
func (_e *TestResponse_Expecter) AssertCookieExpired(_a0 interface{}) *TestResponse_AssertCookieExpired_Call {
	return &TestResponse_AssertCookieExpired_Call{Call: _e.mock.On("AssertCookieExpired", _a0)}
}

func (_c *TestResponse_AssertCookieExpired_Call) Run(run func(_a0 string)) *TestResponse_AssertCookieExpired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *TestResponse_AssertCookieExpired_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertCookieExpired_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertCookieExpired_Call) RunAndReturn(run func(string) testing.TestResponse) *TestResponse_AssertCookieExpired_Call {
	_c.Call.Return(run)
	return _c
}

// AssertCookieMissing provides a mock function with given fields: _a0
func (_m *TestResponse) AssertCookieMissing(_a0 string) testing.TestResponse {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertCookieMissing")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(string) testing.TestResponse); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertCookieMissing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertCookieMissing'
type TestResponse_AssertCookieMissing_Call struct {
	*mock.Call
}

// AssertCookieMissing is a helper method to define mock.On call
//   - _a0 string
func (_e *TestResponse_Expecter) AssertCookieMissing(_a0 interface{}) *TestResponse_AssertCookieMissing_Call {
	return &TestResponse_AssertCookieMissing_Call{Call: _e.mock.On("AssertCookieMissing", _a0)}
}

func (_c *TestResponse_AssertCookieMissing_Call) Run(run func(_a0 string)) *TestResponse_AssertCookieMissing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *TestResponse_AssertCookieMissing_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertCookieMissing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertCookieMissing_Call) RunAndReturn(run func(string) testing.TestResponse) *TestResponse_AssertCookieMissing_Call {
	_c.Call.Return(run)
	return _c
}

// AssertCookieNotExpired provides a mock function with given fields: _a0
func (_m *TestResponse) AssertCookieNotExpired(_a0 string) testing.TestResponse {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertCookieNotExpired")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(string) testing.TestResponse); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertCookieNotExpired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertCookieNotExpired'
type TestResponse_AssertCookieNotExpired_Call struct {
	*mock.Call
}

// AssertCookieNotExpired is a helper method to define mock.On call
//   - _a0 string
func (_e *TestResponse_Expecter) AssertCookieNotExpired(_a0 interface{}) *TestResponse_AssertCookieNotExpired_Call {
	return &TestResponse_AssertCookieNotExpired_Call{Call: _e.mock.On("AssertCookieNotExpired", _a0)}
}

func (_c *TestResponse_AssertCookieNotExpired_Call) Run(run func(_a0 string)) *TestResponse_AssertCookieNotExpired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *TestResponse_AssertCookieNotExpired_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertCookieNotExpired_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertCookieNotExpired_Call) RunAndReturn(run func(string) testing.TestResponse) *TestResponse_AssertCookieNotExpired_Call {
	_c.Call.Return(run)
	return _c
}

// AssertCreated provides a mock function with given fields:
func (_m *TestResponse) AssertCreated() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertCreated")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertCreated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertCreated'
type TestResponse_AssertCreated_Call struct {
	*mock.Call
}

// AssertCreated is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertCreated() *TestResponse_AssertCreated_Call {
	return &TestResponse_AssertCreated_Call{Call: _e.mock.On("AssertCreated")}
}

func (_c *TestResponse_AssertCreated_Call) Run(run func()) *TestResponse_AssertCreated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertCreated_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertCreated_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertCreated_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertCreated_Call {
	_c.Call.Return(run)
	return _c
}

// AssertDontSee provides a mock function with given fields: _a0, _a1
func (_m *TestResponse) AssertDontSee(_a0 []string, _a1 ...bool) testing.TestResponse {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssertDontSee")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func([]string, ...bool) testing.TestResponse); ok {
		r0 = rf(_a0, _a1...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertDontSee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertDontSee'
type TestResponse_AssertDontSee_Call struct {
	*mock.Call
}

// AssertDontSee is a helper method to define mock.On call
//   - _a0 []string
//   - _a1 ...bool
func (_e *TestResponse_Expecter) AssertDontSee(_a0 interface{}, _a1 ...interface{}) *TestResponse_AssertDontSee_Call {
	return &TestResponse_AssertDontSee_Call{Call: _e.mock.On("AssertDontSee",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *TestResponse_AssertDontSee_Call) Run(run func(_a0 []string, _a1 ...bool)) *TestResponse_AssertDontSee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(bool)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *TestResponse_AssertDontSee_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertDontSee_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertDontSee_Call) RunAndReturn(run func([]string, ...bool) testing.TestResponse) *TestResponse_AssertDontSee_Call {
	_c.Call.Return(run)
	return _c
}

// AssertExactJson provides a mock function with given fields: _a0
func (_m *TestResponse) AssertExactJson(_a0 map[string]any) testing.TestResponse {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertExactJson")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(map[string]any) testing.TestResponse); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertExactJson_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertExactJson'
type TestResponse_AssertExactJson_Call struct {
	*mock.Call
}

// AssertExactJson is a helper method to define mock.On call
//   - _a0 map[string]any
func (_e *TestResponse_Expecter) AssertExactJson(_a0 interface{}) *TestResponse_AssertExactJson_Call {
	return &TestResponse_AssertExactJson_Call{Call: _e.mock.On("AssertExactJson", _a0)}
}

func (_c *TestResponse_AssertExactJson_Call) Run(run func(_a0 map[string]any)) *TestResponse_AssertExactJson_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]any))
	})
	return _c
}

func (_c *TestResponse_AssertExactJson_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertExactJson_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertExactJson_Call) RunAndReturn(run func(map[string]any) testing.TestResponse) *TestResponse_AssertExactJson_Call {
	_c.Call.Return(run)
	return _c
}

// AssertFluentJson provides a mock function with given fields: _a0
func (_m *TestResponse) AssertFluentJson(_a0 func(testing.AssertableJSON)) testing.TestResponse {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertFluentJson")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(func(testing.AssertableJSON)) testing.TestResponse); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertFluentJson_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertFluentJson'
type TestResponse_AssertFluentJson_Call struct {
	*mock.Call
}

// AssertFluentJson is a helper method to define mock.On call
//   - _a0 func(testing.AssertableJSON)
func (_e *TestResponse_Expecter) AssertFluentJson(_a0 interface{}) *TestResponse_AssertFluentJson_Call {
	return &TestResponse_AssertFluentJson_Call{Call: _e.mock.On("AssertFluentJson", _a0)}
}

func (_c *TestResponse_AssertFluentJson_Call) Run(run func(_a0 func(testing.AssertableJSON))) *TestResponse_AssertFluentJson_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(func(testing.AssertableJSON)))
	})
	return _c
}

func (_c *TestResponse_AssertFluentJson_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertFluentJson_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertFluentJson_Call) RunAndReturn(run func(func(testing.AssertableJSON)) testing.TestResponse) *TestResponse_AssertFluentJson_Call {
	_c.Call.Return(run)
	return _c
}

// AssertForbidden provides a mock function with given fields:
func (_m *TestResponse) AssertForbidden() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertForbidden")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertForbidden_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertForbidden'
type TestResponse_AssertForbidden_Call struct {
	*mock.Call
}

// AssertForbidden is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertForbidden() *TestResponse_AssertForbidden_Call {
	return &TestResponse_AssertForbidden_Call{Call: _e.mock.On("AssertForbidden")}
}

func (_c *TestResponse_AssertForbidden_Call) Run(run func()) *TestResponse_AssertForbidden_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertForbidden_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertForbidden_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertForbidden_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertForbidden_Call {
	_c.Call.Return(run)
	return _c
}

// AssertFound provides a mock function with given fields:
func (_m *TestResponse) AssertFound() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertFound")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertFound_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertFound'
type TestResponse_AssertFound_Call struct {
	*mock.Call
}

// AssertFound is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertFound() *TestResponse_AssertFound_Call {
	return &TestResponse_AssertFound_Call{Call: _e.mock.On("AssertFound")}
}

func (_c *TestResponse_AssertFound_Call) Run(run func()) *TestResponse_AssertFound_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertFound_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertFound_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertFound_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertFound_Call {
	_c.Call.Return(run)
	return _c
}

// AssertGone provides a mock function with given fields:
func (_m *TestResponse) AssertGone() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertGone")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertGone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertGone'
type TestResponse_AssertGone_Call struct {
	*mock.Call
}

// AssertGone is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertGone() *TestResponse_AssertGone_Call {
	return &TestResponse_AssertGone_Call{Call: _e.mock.On("AssertGone")}
}

func (_c *TestResponse_AssertGone_Call) Run(run func()) *TestResponse_AssertGone_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertGone_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertGone_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertGone_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertGone_Call {
	_c.Call.Return(run)
	return _c
}

// AssertHeader provides a mock function with given fields: headerName, value
func (_m *TestResponse) AssertHeader(headerName string, value string) testing.TestResponse {
	ret := _m.Called(headerName, value)

	if len(ret) == 0 {
		panic("no return value specified for AssertHeader")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(string, string) testing.TestResponse); ok {
		r0 = rf(headerName, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertHeader'
type TestResponse_AssertHeader_Call struct {
	*mock.Call
}

// AssertHeader is a helper method to define mock.On call
//   - headerName string
//   - value string
func (_e *TestResponse_Expecter) AssertHeader(headerName interface{}, value interface{}) *TestResponse_AssertHeader_Call {
	return &TestResponse_AssertHeader_Call{Call: _e.mock.On("AssertHeader", headerName, value)}
}

func (_c *TestResponse_AssertHeader_Call) Run(run func(headerName string, value string)) *TestResponse_AssertHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *TestResponse_AssertHeader_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertHeader_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertHeader_Call) RunAndReturn(run func(string, string) testing.TestResponse) *TestResponse_AssertHeader_Call {
	_c.Call.Return(run)
	return _c
}

// AssertHeaderMissing provides a mock function with given fields: _a0
func (_m *TestResponse) AssertHeaderMissing(_a0 string) testing.TestResponse {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertHeaderMissing")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(string) testing.TestResponse); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertHeaderMissing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertHeaderMissing'
type TestResponse_AssertHeaderMissing_Call struct {
	*mock.Call
}

// AssertHeaderMissing is a helper method to define mock.On call
//   - _a0 string
func (_e *TestResponse_Expecter) AssertHeaderMissing(_a0 interface{}) *TestResponse_AssertHeaderMissing_Call {
	return &TestResponse_AssertHeaderMissing_Call{Call: _e.mock.On("AssertHeaderMissing", _a0)}
}

func (_c *TestResponse_AssertHeaderMissing_Call) Run(run func(_a0 string)) *TestResponse_AssertHeaderMissing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *TestResponse_AssertHeaderMissing_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertHeaderMissing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertHeaderMissing_Call) RunAndReturn(run func(string) testing.TestResponse) *TestResponse_AssertHeaderMissing_Call {
	_c.Call.Return(run)
	return _c
}

// AssertInternalServerError provides a mock function with given fields:
func (_m *TestResponse) AssertInternalServerError() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertInternalServerError")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertInternalServerError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertInternalServerError'
type TestResponse_AssertInternalServerError_Call struct {
	*mock.Call
}

// AssertInternalServerError is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertInternalServerError() *TestResponse_AssertInternalServerError_Call {
	return &TestResponse_AssertInternalServerError_Call{Call: _e.mock.On("AssertInternalServerError")}
}

func (_c *TestResponse_AssertInternalServerError_Call) Run(run func()) *TestResponse_AssertInternalServerError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertInternalServerError_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertInternalServerError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertInternalServerError_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertInternalServerError_Call {
	_c.Call.Return(run)
	return _c
}

// AssertJson provides a mock function with given fields: _a0
func (_m *TestResponse) AssertJson(_a0 map[string]any) testing.TestResponse {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertJson")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(map[string]any) testing.TestResponse); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertJson_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertJson'
type TestResponse_AssertJson_Call struct {
	*mock.Call
}

// AssertJson is a helper method to define mock.On call
//   - _a0 map[string]any
func (_e *TestResponse_Expecter) AssertJson(_a0 interface{}) *TestResponse_AssertJson_Call {
	return &TestResponse_AssertJson_Call{Call: _e.mock.On("AssertJson", _a0)}
}

func (_c *TestResponse_AssertJson_Call) Run(run func(_a0 map[string]any)) *TestResponse_AssertJson_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]any))
	})
	return _c
}

func (_c *TestResponse_AssertJson_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertJson_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertJson_Call) RunAndReturn(run func(map[string]any) testing.TestResponse) *TestResponse_AssertJson_Call {
	_c.Call.Return(run)
	return _c
}

// AssertJsonMissing provides a mock function with given fields: _a0
func (_m *TestResponse) AssertJsonMissing(_a0 map[string]any) testing.TestResponse {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for AssertJsonMissing")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(map[string]any) testing.TestResponse); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertJsonMissing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertJsonMissing'
type TestResponse_AssertJsonMissing_Call struct {
	*mock.Call
}

// AssertJsonMissing is a helper method to define mock.On call
//   - _a0 map[string]any
func (_e *TestResponse_Expecter) AssertJsonMissing(_a0 interface{}) *TestResponse_AssertJsonMissing_Call {
	return &TestResponse_AssertJsonMissing_Call{Call: _e.mock.On("AssertJsonMissing", _a0)}
}

func (_c *TestResponse_AssertJsonMissing_Call) Run(run func(_a0 map[string]any)) *TestResponse_AssertJsonMissing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]any))
	})
	return _c
}

func (_c *TestResponse_AssertJsonMissing_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertJsonMissing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertJsonMissing_Call) RunAndReturn(run func(map[string]any) testing.TestResponse) *TestResponse_AssertJsonMissing_Call {
	_c.Call.Return(run)
	return _c
}

// AssertMethodNotAllowed provides a mock function with given fields:
func (_m *TestResponse) AssertMethodNotAllowed() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertMethodNotAllowed")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertMethodNotAllowed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertMethodNotAllowed'
type TestResponse_AssertMethodNotAllowed_Call struct {
	*mock.Call
}

// AssertMethodNotAllowed is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertMethodNotAllowed() *TestResponse_AssertMethodNotAllowed_Call {
	return &TestResponse_AssertMethodNotAllowed_Call{Call: _e.mock.On("AssertMethodNotAllowed")}
}

func (_c *TestResponse_AssertMethodNotAllowed_Call) Run(run func()) *TestResponse_AssertMethodNotAllowed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertMethodNotAllowed_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertMethodNotAllowed_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertMethodNotAllowed_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertMethodNotAllowed_Call {
	_c.Call.Return(run)
	return _c
}

// AssertMovedPermanently provides a mock function with given fields:
func (_m *TestResponse) AssertMovedPermanently() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertMovedPermanently")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertMovedPermanently_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertMovedPermanently'
type TestResponse_AssertMovedPermanently_Call struct {
	*mock.Call
}

// AssertMovedPermanently is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertMovedPermanently() *TestResponse_AssertMovedPermanently_Call {
	return &TestResponse_AssertMovedPermanently_Call{Call: _e.mock.On("AssertMovedPermanently")}
}

func (_c *TestResponse_AssertMovedPermanently_Call) Run(run func()) *TestResponse_AssertMovedPermanently_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertMovedPermanently_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertMovedPermanently_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertMovedPermanently_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertMovedPermanently_Call {
	_c.Call.Return(run)
	return _c
}

// AssertNoContent provides a mock function with given fields: status
func (_m *TestResponse) AssertNoContent(status ...int) testing.TestResponse {
	_va := make([]interface{}, len(status))
	for _i := range status {
		_va[_i] = status[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssertNoContent")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(...int) testing.TestResponse); ok {
		r0 = rf(status...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertNoContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertNoContent'
type TestResponse_AssertNoContent_Call struct {
	*mock.Call
}

// AssertNoContent is a helper method to define mock.On call
//   - status ...int
func (_e *TestResponse_Expecter) AssertNoContent(status ...interface{}) *TestResponse_AssertNoContent_Call {
	return &TestResponse_AssertNoContent_Call{Call: _e.mock.On("AssertNoContent",
		append([]interface{}{}, status...)...)}
}

func (_c *TestResponse_AssertNoContent_Call) Run(run func(status ...int)) *TestResponse_AssertNoContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *TestResponse_AssertNoContent_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertNoContent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertNoContent_Call) RunAndReturn(run func(...int) testing.TestResponse) *TestResponse_AssertNoContent_Call {
	_c.Call.Return(run)
	return _c
}

// AssertNotAcceptable provides a mock function with given fields:
func (_m *TestResponse) AssertNotAcceptable() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertNotAcceptable")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertNotAcceptable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertNotAcceptable'
type TestResponse_AssertNotAcceptable_Call struct {
	*mock.Call
}

// AssertNotAcceptable is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertNotAcceptable() *TestResponse_AssertNotAcceptable_Call {
	return &TestResponse_AssertNotAcceptable_Call{Call: _e.mock.On("AssertNotAcceptable")}
}

func (_c *TestResponse_AssertNotAcceptable_Call) Run(run func()) *TestResponse_AssertNotAcceptable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertNotAcceptable_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertNotAcceptable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertNotAcceptable_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertNotAcceptable_Call {
	_c.Call.Return(run)
	return _c
}

// AssertNotFound provides a mock function with given fields:
func (_m *TestResponse) AssertNotFound() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertNotFound")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertNotFound_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertNotFound'
type TestResponse_AssertNotFound_Call struct {
	*mock.Call
}

// AssertNotFound is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertNotFound() *TestResponse_AssertNotFound_Call {
	return &TestResponse_AssertNotFound_Call{Call: _e.mock.On("AssertNotFound")}
}

func (_c *TestResponse_AssertNotFound_Call) Run(run func()) *TestResponse_AssertNotFound_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertNotFound_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertNotFound_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertNotFound_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertNotFound_Call {
	_c.Call.Return(run)
	return _c
}

// AssertNotModified provides a mock function with given fields:
func (_m *TestResponse) AssertNotModified() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertNotModified")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertNotModified_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertNotModified'
type TestResponse_AssertNotModified_Call struct {
	*mock.Call
}

// AssertNotModified is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertNotModified() *TestResponse_AssertNotModified_Call {
	return &TestResponse_AssertNotModified_Call{Call: _e.mock.On("AssertNotModified")}
}

func (_c *TestResponse_AssertNotModified_Call) Run(run func()) *TestResponse_AssertNotModified_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertNotModified_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertNotModified_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertNotModified_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertNotModified_Call {
	_c.Call.Return(run)
	return _c
}

// AssertOk provides a mock function with given fields:
func (_m *TestResponse) AssertOk() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertOk")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertOk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertOk'
type TestResponse_AssertOk_Call struct {
	*mock.Call
}

// AssertOk is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertOk() *TestResponse_AssertOk_Call {
	return &TestResponse_AssertOk_Call{Call: _e.mock.On("AssertOk")}
}

func (_c *TestResponse_AssertOk_Call) Run(run func()) *TestResponse_AssertOk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertOk_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertOk_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertOk_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertOk_Call {
	_c.Call.Return(run)
	return _c
}

// AssertPartialContent provides a mock function with given fields:
func (_m *TestResponse) AssertPartialContent() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertPartialContent")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertPartialContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertPartialContent'
type TestResponse_AssertPartialContent_Call struct {
	*mock.Call
}

// AssertPartialContent is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertPartialContent() *TestResponse_AssertPartialContent_Call {
	return &TestResponse_AssertPartialContent_Call{Call: _e.mock.On("AssertPartialContent")}
}

func (_c *TestResponse_AssertPartialContent_Call) Run(run func()) *TestResponse_AssertPartialContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertPartialContent_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertPartialContent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertPartialContent_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertPartialContent_Call {
	_c.Call.Return(run)
	return _c
}

// AssertPaymentRequired provides a mock function with given fields:
func (_m *TestResponse) AssertPaymentRequired() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertPaymentRequired")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertPaymentRequired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertPaymentRequired'
type TestResponse_AssertPaymentRequired_Call struct {
	*mock.Call
}

// AssertPaymentRequired is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertPaymentRequired() *TestResponse_AssertPaymentRequired_Call {
	return &TestResponse_AssertPaymentRequired_Call{Call: _e.mock.On("AssertPaymentRequired")}
}

func (_c *TestResponse_AssertPaymentRequired_Call) Run(run func()) *TestResponse_AssertPaymentRequired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertPaymentRequired_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertPaymentRequired_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertPaymentRequired_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertPaymentRequired_Call {
	_c.Call.Return(run)
	return _c
}

// AssertRequestTimeout provides a mock function with given fields:
func (_m *TestResponse) AssertRequestTimeout() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertRequestTimeout")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertRequestTimeout_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertRequestTimeout'
type TestResponse_AssertRequestTimeout_Call struct {
	*mock.Call
}

// AssertRequestTimeout is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertRequestTimeout() *TestResponse_AssertRequestTimeout_Call {
	return &TestResponse_AssertRequestTimeout_Call{Call: _e.mock.On("AssertRequestTimeout")}
}

func (_c *TestResponse_AssertRequestTimeout_Call) Run(run func()) *TestResponse_AssertRequestTimeout_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertRequestTimeout_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertRequestTimeout_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertRequestTimeout_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertRequestTimeout_Call {
	_c.Call.Return(run)
	return _c
}

// AssertSee provides a mock function with given fields: _a0, _a1
func (_m *TestResponse) AssertSee(_a0 []string, _a1 ...bool) testing.TestResponse {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssertSee")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func([]string, ...bool) testing.TestResponse); ok {
		r0 = rf(_a0, _a1...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertSee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertSee'
type TestResponse_AssertSee_Call struct {
	*mock.Call
}

// AssertSee is a helper method to define mock.On call
//   - _a0 []string
//   - _a1 ...bool
func (_e *TestResponse_Expecter) AssertSee(_a0 interface{}, _a1 ...interface{}) *TestResponse_AssertSee_Call {
	return &TestResponse_AssertSee_Call{Call: _e.mock.On("AssertSee",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *TestResponse_AssertSee_Call) Run(run func(_a0 []string, _a1 ...bool)) *TestResponse_AssertSee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(bool)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *TestResponse_AssertSee_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertSee_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertSee_Call) RunAndReturn(run func([]string, ...bool) testing.TestResponse) *TestResponse_AssertSee_Call {
	_c.Call.Return(run)
	return _c
}

// AssertSeeInOrder provides a mock function with given fields: _a0, _a1
func (_m *TestResponse) AssertSeeInOrder(_a0 []string, _a1 ...bool) testing.TestResponse {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AssertSeeInOrder")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func([]string, ...bool) testing.TestResponse); ok {
		r0 = rf(_a0, _a1...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertSeeInOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertSeeInOrder'
type TestResponse_AssertSeeInOrder_Call struct {
	*mock.Call
}

// AssertSeeInOrder is a helper method to define mock.On call
//   - _a0 []string
//   - _a1 ...bool
func (_e *TestResponse_Expecter) AssertSeeInOrder(_a0 interface{}, _a1 ...interface{}) *TestResponse_AssertSeeInOrder_Call {
	return &TestResponse_AssertSeeInOrder_Call{Call: _e.mock.On("AssertSeeInOrder",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *TestResponse_AssertSeeInOrder_Call) Run(run func(_a0 []string, _a1 ...bool)) *TestResponse_AssertSeeInOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]bool, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(bool)
			}
		}
		run(args[0].([]string), variadicArgs...)
	})
	return _c
}

func (_c *TestResponse_AssertSeeInOrder_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertSeeInOrder_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertSeeInOrder_Call) RunAndReturn(run func([]string, ...bool) testing.TestResponse) *TestResponse_AssertSeeInOrder_Call {
	_c.Call.Return(run)
	return _c
}

// AssertServerError provides a mock function with given fields:
func (_m *TestResponse) AssertServerError() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertServerError")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertServerError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertServerError'
type TestResponse_AssertServerError_Call struct {
	*mock.Call
}

// AssertServerError is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertServerError() *TestResponse_AssertServerError_Call {
	return &TestResponse_AssertServerError_Call{Call: _e.mock.On("AssertServerError")}
}

func (_c *TestResponse_AssertServerError_Call) Run(run func()) *TestResponse_AssertServerError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertServerError_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertServerError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertServerError_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertServerError_Call {
	_c.Call.Return(run)
	return _c
}

// AssertServiceUnavailable provides a mock function with given fields:
func (_m *TestResponse) AssertServiceUnavailable() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertServiceUnavailable")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertServiceUnavailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertServiceUnavailable'
type TestResponse_AssertServiceUnavailable_Call struct {
	*mock.Call
}

// AssertServiceUnavailable is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertServiceUnavailable() *TestResponse_AssertServiceUnavailable_Call {
	return &TestResponse_AssertServiceUnavailable_Call{Call: _e.mock.On("AssertServiceUnavailable")}
}

func (_c *TestResponse_AssertServiceUnavailable_Call) Run(run func()) *TestResponse_AssertServiceUnavailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertServiceUnavailable_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertServiceUnavailable_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertServiceUnavailable_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertServiceUnavailable_Call {
	_c.Call.Return(run)
	return _c
}

// AssertStatus provides a mock function with given fields: status
func (_m *TestResponse) AssertStatus(status int) testing.TestResponse {
	ret := _m.Called(status)

	if len(ret) == 0 {
		panic("no return value specified for AssertStatus")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func(int) testing.TestResponse); ok {
		r0 = rf(status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertStatus'
type TestResponse_AssertStatus_Call struct {
	*mock.Call
}

// AssertStatus is a helper method to define mock.On call
//   - status int
func (_e *TestResponse_Expecter) AssertStatus(status interface{}) *TestResponse_AssertStatus_Call {
	return &TestResponse_AssertStatus_Call{Call: _e.mock.On("AssertStatus", status)}
}

func (_c *TestResponse_AssertStatus_Call) Run(run func(status int)) *TestResponse_AssertStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *TestResponse_AssertStatus_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertStatus_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertStatus_Call) RunAndReturn(run func(int) testing.TestResponse) *TestResponse_AssertStatus_Call {
	_c.Call.Return(run)
	return _c
}

// AssertSuccessful provides a mock function with given fields:
func (_m *TestResponse) AssertSuccessful() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertSuccessful")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertSuccessful_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertSuccessful'
type TestResponse_AssertSuccessful_Call struct {
	*mock.Call
}

// AssertSuccessful is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertSuccessful() *TestResponse_AssertSuccessful_Call {
	return &TestResponse_AssertSuccessful_Call{Call: _e.mock.On("AssertSuccessful")}
}

func (_c *TestResponse_AssertSuccessful_Call) Run(run func()) *TestResponse_AssertSuccessful_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertSuccessful_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertSuccessful_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertSuccessful_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertSuccessful_Call {
	_c.Call.Return(run)
	return _c
}

// AssertTemporaryRedirect provides a mock function with given fields:
func (_m *TestResponse) AssertTemporaryRedirect() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertTemporaryRedirect")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertTemporaryRedirect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertTemporaryRedirect'
type TestResponse_AssertTemporaryRedirect_Call struct {
	*mock.Call
}

// AssertTemporaryRedirect is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertTemporaryRedirect() *TestResponse_AssertTemporaryRedirect_Call {
	return &TestResponse_AssertTemporaryRedirect_Call{Call: _e.mock.On("AssertTemporaryRedirect")}
}

func (_c *TestResponse_AssertTemporaryRedirect_Call) Run(run func()) *TestResponse_AssertTemporaryRedirect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertTemporaryRedirect_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertTemporaryRedirect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertTemporaryRedirect_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertTemporaryRedirect_Call {
	_c.Call.Return(run)
	return _c
}

// AssertTooManyRequests provides a mock function with given fields:
func (_m *TestResponse) AssertTooManyRequests() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertTooManyRequests")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertTooManyRequests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertTooManyRequests'
type TestResponse_AssertTooManyRequests_Call struct {
	*mock.Call
}

// AssertTooManyRequests is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertTooManyRequests() *TestResponse_AssertTooManyRequests_Call {
	return &TestResponse_AssertTooManyRequests_Call{Call: _e.mock.On("AssertTooManyRequests")}
}

func (_c *TestResponse_AssertTooManyRequests_Call) Run(run func()) *TestResponse_AssertTooManyRequests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertTooManyRequests_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertTooManyRequests_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertTooManyRequests_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertTooManyRequests_Call {
	_c.Call.Return(run)
	return _c
}

// AssertUnauthorized provides a mock function with given fields:
func (_m *TestResponse) AssertUnauthorized() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertUnauthorized")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertUnauthorized_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertUnauthorized'
type TestResponse_AssertUnauthorized_Call struct {
	*mock.Call
}

// AssertUnauthorized is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertUnauthorized() *TestResponse_AssertUnauthorized_Call {
	return &TestResponse_AssertUnauthorized_Call{Call: _e.mock.On("AssertUnauthorized")}
}

func (_c *TestResponse_AssertUnauthorized_Call) Run(run func()) *TestResponse_AssertUnauthorized_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertUnauthorized_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertUnauthorized_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertUnauthorized_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertUnauthorized_Call {
	_c.Call.Return(run)
	return _c
}

// AssertUnprocessableEntity provides a mock function with given fields:
func (_m *TestResponse) AssertUnprocessableEntity() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertUnprocessableEntity")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertUnprocessableEntity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertUnprocessableEntity'
type TestResponse_AssertUnprocessableEntity_Call struct {
	*mock.Call
}

// AssertUnprocessableEntity is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertUnprocessableEntity() *TestResponse_AssertUnprocessableEntity_Call {
	return &TestResponse_AssertUnprocessableEntity_Call{Call: _e.mock.On("AssertUnprocessableEntity")}
}

func (_c *TestResponse_AssertUnprocessableEntity_Call) Run(run func()) *TestResponse_AssertUnprocessableEntity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertUnprocessableEntity_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertUnprocessableEntity_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertUnprocessableEntity_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertUnprocessableEntity_Call {
	_c.Call.Return(run)
	return _c
}

// AssertUnsupportedMediaType provides a mock function with given fields:
func (_m *TestResponse) AssertUnsupportedMediaType() testing.TestResponse {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for AssertUnsupportedMediaType")
	}

	var r0 testing.TestResponse
	if rf, ok := ret.Get(0).(func() testing.TestResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(testing.TestResponse)
		}
	}

	return r0
}

// TestResponse_AssertUnsupportedMediaType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssertUnsupportedMediaType'
type TestResponse_AssertUnsupportedMediaType_Call struct {
	*mock.Call
}

// AssertUnsupportedMediaType is a helper method to define mock.On call
func (_e *TestResponse_Expecter) AssertUnsupportedMediaType() *TestResponse_AssertUnsupportedMediaType_Call {
	return &TestResponse_AssertUnsupportedMediaType_Call{Call: _e.mock.On("AssertUnsupportedMediaType")}
}

func (_c *TestResponse_AssertUnsupportedMediaType_Call) Run(run func()) *TestResponse_AssertUnsupportedMediaType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_AssertUnsupportedMediaType_Call) Return(_a0 testing.TestResponse) *TestResponse_AssertUnsupportedMediaType_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_AssertUnsupportedMediaType_Call) RunAndReturn(run func() testing.TestResponse) *TestResponse_AssertUnsupportedMediaType_Call {
	_c.Call.Return(run)
	return _c
}

// Content provides a mock function with given fields:
func (_m *TestResponse) Content() (string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Content")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TestResponse_Content_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Content'
type TestResponse_Content_Call struct {
	*mock.Call
}

// Content is a helper method to define mock.On call
func (_e *TestResponse_Expecter) Content() *TestResponse_Content_Call {
	return &TestResponse_Content_Call{Call: _e.mock.On("Content")}
}

func (_c *TestResponse_Content_Call) Run(run func()) *TestResponse_Content_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_Content_Call) Return(_a0 string, _a1 error) *TestResponse_Content_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TestResponse_Content_Call) RunAndReturn(run func() (string, error)) *TestResponse_Content_Call {
	_c.Call.Return(run)
	return _c
}

// Cookie provides a mock function with given fields: name
func (_m *TestResponse) Cookie(name string) *http.Cookie {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Cookie")
	}

	var r0 *http.Cookie
	if rf, ok := ret.Get(0).(func(string) *http.Cookie); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Cookie)
		}
	}

	return r0
}

// TestResponse_Cookie_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cookie'
type TestResponse_Cookie_Call struct {
	*mock.Call
}

// Cookie is a helper method to define mock.On call
//   - name string
func (_e *TestResponse_Expecter) Cookie(name interface{}) *TestResponse_Cookie_Call {
	return &TestResponse_Cookie_Call{Call: _e.mock.On("Cookie", name)}
}

func (_c *TestResponse_Cookie_Call) Run(run func(name string)) *TestResponse_Cookie_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *TestResponse_Cookie_Call) Return(_a0 *http.Cookie) *TestResponse_Cookie_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_Cookie_Call) RunAndReturn(run func(string) *http.Cookie) *TestResponse_Cookie_Call {
	_c.Call.Return(run)
	return _c
}

// Cookies provides a mock function with given fields:
func (_m *TestResponse) Cookies() []*http.Cookie {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Cookies")
	}

	var r0 []*http.Cookie
	if rf, ok := ret.Get(0).(func() []*http.Cookie); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*http.Cookie)
		}
	}

	return r0
}

// TestResponse_Cookies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cookies'
type TestResponse_Cookies_Call struct {
	*mock.Call
}

// Cookies is a helper method to define mock.On call
func (_e *TestResponse_Expecter) Cookies() *TestResponse_Cookies_Call {
	return &TestResponse_Cookies_Call{Call: _e.mock.On("Cookies")}
}

func (_c *TestResponse_Cookies_Call) Run(run func()) *TestResponse_Cookies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_Cookies_Call) Return(_a0 []*http.Cookie) *TestResponse_Cookies_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_Cookies_Call) RunAndReturn(run func() []*http.Cookie) *TestResponse_Cookies_Call {
	_c.Call.Return(run)
	return _c
}

// Headers provides a mock function with given fields:
func (_m *TestResponse) Headers() http.Header {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Headers")
	}

	var r0 http.Header
	if rf, ok := ret.Get(0).(func() http.Header); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Header)
		}
	}

	return r0
}

// TestResponse_Headers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Headers'
type TestResponse_Headers_Call struct {
	*mock.Call
}

// Headers is a helper method to define mock.On call
func (_e *TestResponse_Expecter) Headers() *TestResponse_Headers_Call {
	return &TestResponse_Headers_Call{Call: _e.mock.On("Headers")}
}

func (_c *TestResponse_Headers_Call) Run(run func()) *TestResponse_Headers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_Headers_Call) Return(_a0 http.Header) *TestResponse_Headers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_Headers_Call) RunAndReturn(run func() http.Header) *TestResponse_Headers_Call {
	_c.Call.Return(run)
	return _c
}

// IsServerError provides a mock function with given fields:
func (_m *TestResponse) IsServerError() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsServerError")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// TestResponse_IsServerError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsServerError'
type TestResponse_IsServerError_Call struct {
	*mock.Call
}

// IsServerError is a helper method to define mock.On call
func (_e *TestResponse_Expecter) IsServerError() *TestResponse_IsServerError_Call {
	return &TestResponse_IsServerError_Call{Call: _e.mock.On("IsServerError")}
}

func (_c *TestResponse_IsServerError_Call) Run(run func()) *TestResponse_IsServerError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_IsServerError_Call) Return(_a0 bool) *TestResponse_IsServerError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_IsServerError_Call) RunAndReturn(run func() bool) *TestResponse_IsServerError_Call {
	_c.Call.Return(run)
	return _c
}

// IsSuccessful provides a mock function with given fields:
func (_m *TestResponse) IsSuccessful() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsSuccessful")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// TestResponse_IsSuccessful_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsSuccessful'
type TestResponse_IsSuccessful_Call struct {
	*mock.Call
}

// IsSuccessful is a helper method to define mock.On call
func (_e *TestResponse_Expecter) IsSuccessful() *TestResponse_IsSuccessful_Call {
	return &TestResponse_IsSuccessful_Call{Call: _e.mock.On("IsSuccessful")}
}

func (_c *TestResponse_IsSuccessful_Call) Run(run func()) *TestResponse_IsSuccessful_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_IsSuccessful_Call) Return(_a0 bool) *TestResponse_IsSuccessful_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *TestResponse_IsSuccessful_Call) RunAndReturn(run func() bool) *TestResponse_IsSuccessful_Call {
	_c.Call.Return(run)
	return _c
}

// Json provides a mock function with given fields:
func (_m *TestResponse) Json() (map[string]any, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Json")
	}

	var r0 map[string]any
	var r1 error
	if rf, ok := ret.Get(0).(func() (map[string]any, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() map[string]any); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]any)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TestResponse_Json_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Json'
type TestResponse_Json_Call struct {
	*mock.Call
}

// Json is a helper method to define mock.On call
func (_e *TestResponse_Expecter) Json() *TestResponse_Json_Call {
	return &TestResponse_Json_Call{Call: _e.mock.On("Json")}
}

func (_c *TestResponse_Json_Call) Run(run func()) *TestResponse_Json_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_Json_Call) Return(_a0 map[string]any, _a1 error) *TestResponse_Json_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TestResponse_Json_Call) RunAndReturn(run func() (map[string]any, error)) *TestResponse_Json_Call {
	_c.Call.Return(run)
	return _c
}

// Session provides a mock function with given fields:
func (_m *TestResponse) Session() (map[string]any, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Session")
	}

	var r0 map[string]any
	var r1 error
	if rf, ok := ret.Get(0).(func() (map[string]any, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() map[string]any); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]any)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TestResponse_Session_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Session'
type TestResponse_Session_Call struct {
	*mock.Call
}

// Session is a helper method to define mock.On call
func (_e *TestResponse_Expecter) Session() *TestResponse_Session_Call {
	return &TestResponse_Session_Call{Call: _e.mock.On("Session")}
}

func (_c *TestResponse_Session_Call) Run(run func()) *TestResponse_Session_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *TestResponse_Session_Call) Return(_a0 map[string]any, _a1 error) *TestResponse_Session_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *TestResponse_Session_Call) RunAndReturn(run func() (map[string]any, error)) *TestResponse_Session_Call {
	_c.Call.Return(run)
	return _c
}

// NewTestResponse creates a new instance of TestResponse. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTestResponse(t interface {
	mock.TestingT
	Cleanup(func())
}) *TestResponse {
	mock := &TestResponse{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
