// Code generated by mockery. DO NOT EDIT.

package schema

import (
	orm "github.com/goravel/framework/contracts/database/orm"
	schema "github.com/goravel/framework/contracts/database/schema"
	mock "github.com/stretchr/testify/mock"
)

// Blueprint is an autogenerated mock type for the Blueprint type
type Blueprint struct {
	mock.Mock
}

type Blueprint_Expecter struct {
	mock *mock.Mock
}

func (_m *Blueprint) EXPECT() *Blueprint_Expecter {
	return &Blueprint_Expecter{mock: &_m.Mock}
}

// BigIncrements provides a mock function with given fields: column
func (_m *Blueprint) BigIncrements(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for BigIncrements")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_BigIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BigIncrements'
type Blueprint_BigIncrements_Call struct {
	*mock.Call
}

// BigIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) BigIncrements(column interface{}) *Blueprint_BigIncrements_Call {
	return &Blueprint_BigIncrements_Call{Call: _e.mock.On("BigIncrements", column)}
}

func (_c *Blueprint_BigIncrements_Call) Run(run func(column string)) *Blueprint_BigIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_BigIncrements_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_BigIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_BigIncrements_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_BigIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// BigInteger provides a mock function with given fields: column
func (_m *Blueprint) BigInteger(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for BigInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_BigInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BigInteger'
type Blueprint_BigInteger_Call struct {
	*mock.Call
}

// BigInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) BigInteger(column interface{}) *Blueprint_BigInteger_Call {
	return &Blueprint_BigInteger_Call{Call: _e.mock.On("BigInteger", column)}
}

func (_c *Blueprint_BigInteger_Call) Run(run func(column string)) *Blueprint_BigInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_BigInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_BigInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_BigInteger_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_BigInteger_Call {
	_c.Call.Return(run)
	return _c
}

// Build provides a mock function with given fields: query, grammar
func (_m *Blueprint) Build(query orm.Query, grammar schema.Grammar) error {
	ret := _m.Called(query, grammar)

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(orm.Query, schema.Grammar) error); ok {
		r0 = rf(query, grammar)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Blueprint_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type Blueprint_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
//   - query orm.Query
//   - grammar schema.Grammar
func (_e *Blueprint_Expecter) Build(query interface{}, grammar interface{}) *Blueprint_Build_Call {
	return &Blueprint_Build_Call{Call: _e.mock.On("Build", query, grammar)}
}

func (_c *Blueprint_Build_Call) Run(run func(query orm.Query, grammar schema.Grammar)) *Blueprint_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(orm.Query), args[1].(schema.Grammar))
	})
	return _c
}

func (_c *Blueprint_Build_Call) Return(_a0 error) *Blueprint_Build_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Build_Call) RunAndReturn(run func(orm.Query, schema.Grammar) error) *Blueprint_Build_Call {
	_c.Call.Return(run)
	return _c
}

// Char provides a mock function with given fields: column, length
func (_m *Blueprint) Char(column string, length ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(length))
	for _i := range length {
		_va[_i] = length[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Char")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, length...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Char_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Char'
type Blueprint_Char_Call struct {
	*mock.Call
}

// Char is a helper method to define mock.On call
//   - column string
//   - length ...int
func (_e *Blueprint_Expecter) Char(column interface{}, length ...interface{}) *Blueprint_Char_Call {
	return &Blueprint_Char_Call{Call: _e.mock.On("Char",
		append([]interface{}{column}, length...)...)}
}

func (_c *Blueprint_Char_Call) Run(run func(column string, length ...int)) *Blueprint_Char_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Char_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Char_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Char_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_Char_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields:
func (_m *Blueprint) Create() {
	_m.Called()
}

// Blueprint_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Blueprint_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
func (_e *Blueprint_Expecter) Create() *Blueprint_Create_Call {
	return &Blueprint_Create_Call{Call: _e.mock.On("Create")}
}

func (_c *Blueprint_Create_Call) Run(run func()) *Blueprint_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_Create_Call) Return() *Blueprint_Create_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Create_Call) RunAndReturn(run func()) *Blueprint_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Decimal provides a mock function with given fields: column
func (_m *Blueprint) Decimal(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Decimal")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Decimal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decimal'
type Blueprint_Decimal_Call struct {
	*mock.Call
}

// Decimal is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Decimal(column interface{}) *Blueprint_Decimal_Call {
	return &Blueprint_Decimal_Call{Call: _e.mock.On("Decimal", column)}
}

func (_c *Blueprint_Decimal_Call) Run(run func(column string)) *Blueprint_Decimal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Decimal_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Decimal_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Decimal_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Decimal_Call {
	_c.Call.Return(run)
	return _c
}

// Double provides a mock function with given fields: column
func (_m *Blueprint) Double(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Double")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Double_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Double'
type Blueprint_Double_Call struct {
	*mock.Call
}

// Double is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Double(column interface{}) *Blueprint_Double_Call {
	return &Blueprint_Double_Call{Call: _e.mock.On("Double", column)}
}

func (_c *Blueprint_Double_Call) Run(run func(column string)) *Blueprint_Double_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Double_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Double_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Double_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Double_Call {
	_c.Call.Return(run)
	return _c
}

// DropIfExists provides a mock function with given fields:
func (_m *Blueprint) DropIfExists() {
	_m.Called()
}

// Blueprint_DropIfExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropIfExists'
type Blueprint_DropIfExists_Call struct {
	*mock.Call
}

// DropIfExists is a helper method to define mock.On call
func (_e *Blueprint_Expecter) DropIfExists() *Blueprint_DropIfExists_Call {
	return &Blueprint_DropIfExists_Call{Call: _e.mock.On("DropIfExists")}
}

func (_c *Blueprint_DropIfExists_Call) Run(run func()) *Blueprint_DropIfExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_DropIfExists_Call) Return() *Blueprint_DropIfExists_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_DropIfExists_Call) RunAndReturn(run func()) *Blueprint_DropIfExists_Call {
	_c.Call.Return(run)
	return _c
}

// Enum provides a mock function with given fields: column, array
func (_m *Blueprint) Enum(column string, array []string) schema.ColumnDefinition {
	ret := _m.Called(column, array)

	if len(ret) == 0 {
		panic("no return value specified for Enum")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, []string) schema.ColumnDefinition); ok {
		r0 = rf(column, array)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Enum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Enum'
type Blueprint_Enum_Call struct {
	*mock.Call
}

// Enum is a helper method to define mock.On call
//   - column string
//   - array []string
func (_e *Blueprint_Expecter) Enum(column interface{}, array interface{}) *Blueprint_Enum_Call {
	return &Blueprint_Enum_Call{Call: _e.mock.On("Enum", column, array)}
}

func (_c *Blueprint_Enum_Call) Run(run func(column string, array []string)) *Blueprint_Enum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]string))
	})
	return _c
}

func (_c *Blueprint_Enum_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Enum_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Enum_Call) RunAndReturn(run func(string, []string) schema.ColumnDefinition) *Blueprint_Enum_Call {
	_c.Call.Return(run)
	return _c
}

// Float provides a mock function with given fields: column, precision
func (_m *Blueprint) Float(column string, precision ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(precision))
	for _i := range precision {
		_va[_i] = precision[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Float")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, precision...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Float_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Float'
type Blueprint_Float_Call struct {
	*mock.Call
}

// Float is a helper method to define mock.On call
//   - column string
//   - precision ...int
func (_e *Blueprint_Expecter) Float(column interface{}, precision ...interface{}) *Blueprint_Float_Call {
	return &Blueprint_Float_Call{Call: _e.mock.On("Float",
		append([]interface{}{column}, precision...)...)}
}

func (_c *Blueprint_Float_Call) Run(run func(column string, precision ...int)) *Blueprint_Float_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Float_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Float_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Float_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_Float_Call {
	_c.Call.Return(run)
	return _c
}

// Foreign provides a mock function with given fields: column
func (_m *Blueprint) Foreign(column ...string) schema.ForeignKeyDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Foreign")
	}

	var r0 schema.ForeignKeyDefinition
	if rf, ok := ret.Get(0).(func(...string) schema.ForeignKeyDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ForeignKeyDefinition)
		}
	}

	return r0
}

// Blueprint_Foreign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Foreign'
type Blueprint_Foreign_Call struct {
	*mock.Call
}

// Foreign is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) Foreign(column ...interface{}) *Blueprint_Foreign_Call {
	return &Blueprint_Foreign_Call{Call: _e.mock.On("Foreign",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_Foreign_Call) Run(run func(column ...string)) *Blueprint_Foreign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Foreign_Call) Return(_a0 schema.ForeignKeyDefinition) *Blueprint_Foreign_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Foreign_Call) RunAndReturn(run func(...string) schema.ForeignKeyDefinition) *Blueprint_Foreign_Call {
	_c.Call.Return(run)
	return _c
}

// GetAddedColumns provides a mock function with given fields:
func (_m *Blueprint) GetAddedColumns() []schema.ColumnDefinition {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetAddedColumns")
	}

	var r0 []schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func() []schema.ColumnDefinition); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_GetAddedColumns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAddedColumns'
type Blueprint_GetAddedColumns_Call struct {
	*mock.Call
}

// GetAddedColumns is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetAddedColumns() *Blueprint_GetAddedColumns_Call {
	return &Blueprint_GetAddedColumns_Call{Call: _e.mock.On("GetAddedColumns")}
}

func (_c *Blueprint_GetAddedColumns_Call) Run(run func()) *Blueprint_GetAddedColumns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetAddedColumns_Call) Return(_a0 []schema.ColumnDefinition) *Blueprint_GetAddedColumns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetAddedColumns_Call) RunAndReturn(run func() []schema.ColumnDefinition) *Blueprint_GetAddedColumns_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommands provides a mock function with given fields:
func (_m *Blueprint) GetCommands() []*schema.Command {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCommands")
	}

	var r0 []*schema.Command
	if rf, ok := ret.Get(0).(func() []*schema.Command); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*schema.Command)
		}
	}

	return r0
}

// Blueprint_GetCommands_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommands'
type Blueprint_GetCommands_Call struct {
	*mock.Call
}

// GetCommands is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetCommands() *Blueprint_GetCommands_Call {
	return &Blueprint_GetCommands_Call{Call: _e.mock.On("GetCommands")}
}

func (_c *Blueprint_GetCommands_Call) Run(run func()) *Blueprint_GetCommands_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetCommands_Call) Return(_a0 []*schema.Command) *Blueprint_GetCommands_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetCommands_Call) RunAndReturn(run func() []*schema.Command) *Blueprint_GetCommands_Call {
	_c.Call.Return(run)
	return _c
}

// GetTableName provides a mock function with given fields:
func (_m *Blueprint) GetTableName() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetTableName")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Blueprint_GetTableName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTableName'
type Blueprint_GetTableName_Call struct {
	*mock.Call
}

// GetTableName is a helper method to define mock.On call
func (_e *Blueprint_Expecter) GetTableName() *Blueprint_GetTableName_Call {
	return &Blueprint_GetTableName_Call{Call: _e.mock.On("GetTableName")}
}

func (_c *Blueprint_GetTableName_Call) Run(run func()) *Blueprint_GetTableName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Blueprint_GetTableName_Call) Return(_a0 string) *Blueprint_GetTableName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_GetTableName_Call) RunAndReturn(run func() string) *Blueprint_GetTableName_Call {
	_c.Call.Return(run)
	return _c
}

// HasCommand provides a mock function with given fields: command
func (_m *Blueprint) HasCommand(command string) bool {
	ret := _m.Called(command)

	if len(ret) == 0 {
		panic("no return value specified for HasCommand")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(command)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Blueprint_HasCommand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasCommand'
type Blueprint_HasCommand_Call struct {
	*mock.Call
}

// HasCommand is a helper method to define mock.On call
//   - command string
func (_e *Blueprint_Expecter) HasCommand(command interface{}) *Blueprint_HasCommand_Call {
	return &Blueprint_HasCommand_Call{Call: _e.mock.On("HasCommand", command)}
}

func (_c *Blueprint_HasCommand_Call) Run(run func(command string)) *Blueprint_HasCommand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_HasCommand_Call) Return(_a0 bool) *Blueprint_HasCommand_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_HasCommand_Call) RunAndReturn(run func(string) bool) *Blueprint_HasCommand_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function with given fields: column
func (_m *Blueprint) ID(column ...string) schema.ColumnDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(...string) schema.ColumnDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type Blueprint_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) ID(column ...interface{}) *Blueprint_ID_Call {
	return &Blueprint_ID_Call{Call: _e.mock.On("ID",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_ID_Call) Run(run func(column ...string)) *Blueprint_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_ID_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_ID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_ID_Call) RunAndReturn(run func(...string) schema.ColumnDefinition) *Blueprint_ID_Call {
	_c.Call.Return(run)
	return _c
}

// Increments provides a mock function with given fields: column
func (_m *Blueprint) Increments(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Increments")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Increments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Increments'
type Blueprint_Increments_Call struct {
	*mock.Call
}

// Increments is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Increments(column interface{}) *Blueprint_Increments_Call {
	return &Blueprint_Increments_Call{Call: _e.mock.On("Increments", column)}
}

func (_c *Blueprint_Increments_Call) Run(run func(column string)) *Blueprint_Increments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Increments_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Increments_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Increments_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Increments_Call {
	_c.Call.Return(run)
	return _c
}

// Index provides a mock function with given fields: column
func (_m *Blueprint) Index(column ...string) schema.IndexDefinition {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Index")
	}

	var r0 schema.IndexDefinition
	if rf, ok := ret.Get(0).(func(...string) schema.IndexDefinition); ok {
		r0 = rf(column...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.IndexDefinition)
		}
	}

	return r0
}

// Blueprint_Index_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Index'
type Blueprint_Index_Call struct {
	*mock.Call
}

// Index is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) Index(column ...interface{}) *Blueprint_Index_Call {
	return &Blueprint_Index_Call{Call: _e.mock.On("Index",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_Index_Call) Run(run func(column ...string)) *Blueprint_Index_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Index_Call) Return(_a0 schema.IndexDefinition) *Blueprint_Index_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Index_Call) RunAndReturn(run func(...string) schema.IndexDefinition) *Blueprint_Index_Call {
	_c.Call.Return(run)
	return _c
}

// Integer provides a mock function with given fields: column
func (_m *Blueprint) Integer(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Integer")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Integer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Integer'
type Blueprint_Integer_Call struct {
	*mock.Call
}

// Integer is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Integer(column interface{}) *Blueprint_Integer_Call {
	return &Blueprint_Integer_Call{Call: _e.mock.On("Integer", column)}
}

func (_c *Blueprint_Integer_Call) Run(run func(column string)) *Blueprint_Integer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Integer_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Integer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Integer_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Integer_Call {
	_c.Call.Return(run)
	return _c
}

// IntegerIncrements provides a mock function with given fields: column
func (_m *Blueprint) IntegerIncrements(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for IntegerIncrements")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_IntegerIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IntegerIncrements'
type Blueprint_IntegerIncrements_Call struct {
	*mock.Call
}

// IntegerIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) IntegerIncrements(column interface{}) *Blueprint_IntegerIncrements_Call {
	return &Blueprint_IntegerIncrements_Call{Call: _e.mock.On("IntegerIncrements", column)}
}

func (_c *Blueprint_IntegerIncrements_Call) Run(run func(column string)) *Blueprint_IntegerIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_IntegerIncrements_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_IntegerIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_IntegerIncrements_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_IntegerIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// Json provides a mock function with given fields: column
func (_m *Blueprint) Json(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Json")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Json_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Json'
type Blueprint_Json_Call struct {
	*mock.Call
}

// Json is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Json(column interface{}) *Blueprint_Json_Call {
	return &Blueprint_Json_Call{Call: _e.mock.On("Json", column)}
}

func (_c *Blueprint_Json_Call) Run(run func(column string)) *Blueprint_Json_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Json_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Json_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Json_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Json_Call {
	_c.Call.Return(run)
	return _c
}

// Jsonb provides a mock function with given fields: column
func (_m *Blueprint) Jsonb(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Jsonb")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Jsonb_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Jsonb'
type Blueprint_Jsonb_Call struct {
	*mock.Call
}

// Jsonb is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Jsonb(column interface{}) *Blueprint_Jsonb_Call {
	return &Blueprint_Jsonb_Call{Call: _e.mock.On("Jsonb", column)}
}

func (_c *Blueprint_Jsonb_Call) Run(run func(column string)) *Blueprint_Jsonb_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Jsonb_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Jsonb_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Jsonb_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Jsonb_Call {
	_c.Call.Return(run)
	return _c
}

// LongText provides a mock function with given fields: column
func (_m *Blueprint) LongText(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for LongText")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_LongText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LongText'
type Blueprint_LongText_Call struct {
	*mock.Call
}

// LongText is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) LongText(column interface{}) *Blueprint_LongText_Call {
	return &Blueprint_LongText_Call{Call: _e.mock.On("LongText", column)}
}

func (_c *Blueprint_LongText_Call) Run(run func(column string)) *Blueprint_LongText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_LongText_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_LongText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_LongText_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_LongText_Call {
	_c.Call.Return(run)
	return _c
}

// MediumIncrements provides a mock function with given fields: column
func (_m *Blueprint) MediumIncrements(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for MediumIncrements")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_MediumIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MediumIncrements'
type Blueprint_MediumIncrements_Call struct {
	*mock.Call
}

// MediumIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) MediumIncrements(column interface{}) *Blueprint_MediumIncrements_Call {
	return &Blueprint_MediumIncrements_Call{Call: _e.mock.On("MediumIncrements", column)}
}

func (_c *Blueprint_MediumIncrements_Call) Run(run func(column string)) *Blueprint_MediumIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_MediumIncrements_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_MediumIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_MediumIncrements_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_MediumIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// MediumInteger provides a mock function with given fields: column
func (_m *Blueprint) MediumInteger(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for MediumInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_MediumInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MediumInteger'
type Blueprint_MediumInteger_Call struct {
	*mock.Call
}

// MediumInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) MediumInteger(column interface{}) *Blueprint_MediumInteger_Call {
	return &Blueprint_MediumInteger_Call{Call: _e.mock.On("MediumInteger", column)}
}

func (_c *Blueprint_MediumInteger_Call) Run(run func(column string)) *Blueprint_MediumInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_MediumInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_MediumInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_MediumInteger_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_MediumInteger_Call {
	_c.Call.Return(run)
	return _c
}

// MediumText provides a mock function with given fields: column
func (_m *Blueprint) MediumText(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for MediumText")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_MediumText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MediumText'
type Blueprint_MediumText_Call struct {
	*mock.Call
}

// MediumText is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) MediumText(column interface{}) *Blueprint_MediumText_Call {
	return &Blueprint_MediumText_Call{Call: _e.mock.On("MediumText", column)}
}

func (_c *Blueprint_MediumText_Call) Run(run func(column string)) *Blueprint_MediumText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_MediumText_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_MediumText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_MediumText_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_MediumText_Call {
	_c.Call.Return(run)
	return _c
}

// Primary provides a mock function with given fields: column
func (_m *Blueprint) Primary(column ...string) {
	_va := make([]interface{}, len(column))
	for _i := range column {
		_va[_i] = column[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Blueprint_Primary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Primary'
type Blueprint_Primary_Call struct {
	*mock.Call
}

// Primary is a helper method to define mock.On call
//   - column ...string
func (_e *Blueprint_Expecter) Primary(column ...interface{}) *Blueprint_Primary_Call {
	return &Blueprint_Primary_Call{Call: _e.mock.On("Primary",
		append([]interface{}{}, column...)...)}
}

func (_c *Blueprint_Primary_Call) Run(run func(column ...string)) *Blueprint_Primary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_Primary_Call) Return() *Blueprint_Primary_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_Primary_Call) RunAndReturn(run func(...string)) *Blueprint_Primary_Call {
	_c.Call.Return(run)
	return _c
}

// SetTable provides a mock function with given fields: name
func (_m *Blueprint) SetTable(name string) {
	_m.Called(name)
}

// Blueprint_SetTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTable'
type Blueprint_SetTable_Call struct {
	*mock.Call
}

// SetTable is a helper method to define mock.On call
//   - name string
func (_e *Blueprint_Expecter) SetTable(name interface{}) *Blueprint_SetTable_Call {
	return &Blueprint_SetTable_Call{Call: _e.mock.On("SetTable", name)}
}

func (_c *Blueprint_SetTable_Call) Run(run func(name string)) *Blueprint_SetTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_SetTable_Call) Return() *Blueprint_SetTable_Call {
	_c.Call.Return()
	return _c
}

func (_c *Blueprint_SetTable_Call) RunAndReturn(run func(string)) *Blueprint_SetTable_Call {
	_c.Call.Return(run)
	return _c
}

// SmallIncrements provides a mock function with given fields: column
func (_m *Blueprint) SmallIncrements(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for SmallIncrements")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_SmallIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SmallIncrements'
type Blueprint_SmallIncrements_Call struct {
	*mock.Call
}

// SmallIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) SmallIncrements(column interface{}) *Blueprint_SmallIncrements_Call {
	return &Blueprint_SmallIncrements_Call{Call: _e.mock.On("SmallIncrements", column)}
}

func (_c *Blueprint_SmallIncrements_Call) Run(run func(column string)) *Blueprint_SmallIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_SmallIncrements_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_SmallIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_SmallIncrements_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_SmallIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// SmallInteger provides a mock function with given fields: column
func (_m *Blueprint) SmallInteger(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for SmallInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_SmallInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SmallInteger'
type Blueprint_SmallInteger_Call struct {
	*mock.Call
}

// SmallInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) SmallInteger(column interface{}) *Blueprint_SmallInteger_Call {
	return &Blueprint_SmallInteger_Call{Call: _e.mock.On("SmallInteger", column)}
}

func (_c *Blueprint_SmallInteger_Call) Run(run func(column string)) *Blueprint_SmallInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_SmallInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_SmallInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_SmallInteger_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_SmallInteger_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function with given fields: column, length
func (_m *Blueprint) String(column string, length ...int) schema.ColumnDefinition {
	_va := make([]interface{}, len(length))
	for _i := range length {
		_va[_i] = length[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string, ...int) schema.ColumnDefinition); ok {
		r0 = rf(column, length...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type Blueprint_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
//   - column string
//   - length ...int
func (_e *Blueprint_Expecter) String(column interface{}, length ...interface{}) *Blueprint_String_Call {
	return &Blueprint_String_Call{Call: _e.mock.On("String",
		append([]interface{}{column}, length...)...)}
}

func (_c *Blueprint_String_Call) Run(run func(column string, length ...int)) *Blueprint_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Blueprint_String_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_String_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_String_Call) RunAndReturn(run func(string, ...int) schema.ColumnDefinition) *Blueprint_String_Call {
	_c.Call.Return(run)
	return _c
}

// Text provides a mock function with given fields: column
func (_m *Blueprint) Text(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Text")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_Text_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Text'
type Blueprint_Text_Call struct {
	*mock.Call
}

// Text is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) Text(column interface{}) *Blueprint_Text_Call {
	return &Blueprint_Text_Call{Call: _e.mock.On("Text", column)}
}

func (_c *Blueprint_Text_Call) Run(run func(column string)) *Blueprint_Text_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_Text_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_Text_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_Text_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_Text_Call {
	_c.Call.Return(run)
	return _c
}

// TinyIncrements provides a mock function with given fields: column
func (_m *Blueprint) TinyIncrements(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TinyIncrements")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_TinyIncrements_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TinyIncrements'
type Blueprint_TinyIncrements_Call struct {
	*mock.Call
}

// TinyIncrements is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) TinyIncrements(column interface{}) *Blueprint_TinyIncrements_Call {
	return &Blueprint_TinyIncrements_Call{Call: _e.mock.On("TinyIncrements", column)}
}

func (_c *Blueprint_TinyIncrements_Call) Run(run func(column string)) *Blueprint_TinyIncrements_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_TinyIncrements_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_TinyIncrements_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_TinyIncrements_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_TinyIncrements_Call {
	_c.Call.Return(run)
	return _c
}

// TinyInteger provides a mock function with given fields: column
func (_m *Blueprint) TinyInteger(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TinyInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_TinyInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TinyInteger'
type Blueprint_TinyInteger_Call struct {
	*mock.Call
}

// TinyInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) TinyInteger(column interface{}) *Blueprint_TinyInteger_Call {
	return &Blueprint_TinyInteger_Call{Call: _e.mock.On("TinyInteger", column)}
}

func (_c *Blueprint_TinyInteger_Call) Run(run func(column string)) *Blueprint_TinyInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_TinyInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_TinyInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_TinyInteger_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_TinyInteger_Call {
	_c.Call.Return(run)
	return _c
}

// TinyText provides a mock function with given fields: column
func (_m *Blueprint) TinyText(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for TinyText")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_TinyText_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TinyText'
type Blueprint_TinyText_Call struct {
	*mock.Call
}

// TinyText is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) TinyText(column interface{}) *Blueprint_TinyText_Call {
	return &Blueprint_TinyText_Call{Call: _e.mock.On("TinyText", column)}
}

func (_c *Blueprint_TinyText_Call) Run(run func(column string)) *Blueprint_TinyText_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_TinyText_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_TinyText_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_TinyText_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_TinyText_Call {
	_c.Call.Return(run)
	return _c
}

// ToSql provides a mock function with given fields: grammar
func (_m *Blueprint) ToSql(grammar schema.Grammar) []string {
	ret := _m.Called(grammar)

	if len(ret) == 0 {
		panic("no return value specified for ToSql")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func(schema.Grammar) []string); ok {
		r0 = rf(grammar)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Blueprint_ToSql_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ToSql'
type Blueprint_ToSql_Call struct {
	*mock.Call
}

// ToSql is a helper method to define mock.On call
//   - grammar schema.Grammar
func (_e *Blueprint_Expecter) ToSql(grammar interface{}) *Blueprint_ToSql_Call {
	return &Blueprint_ToSql_Call{Call: _e.mock.On("ToSql", grammar)}
}

func (_c *Blueprint_ToSql_Call) Run(run func(grammar schema.Grammar)) *Blueprint_ToSql_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(schema.Grammar))
	})
	return _c
}

func (_c *Blueprint_ToSql_Call) Return(_a0 []string) *Blueprint_ToSql_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_ToSql_Call) RunAndReturn(run func(schema.Grammar) []string) *Blueprint_ToSql_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedBigInteger provides a mock function with given fields: column
func (_m *Blueprint) UnsignedBigInteger(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedBigInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedBigInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedBigInteger'
type Blueprint_UnsignedBigInteger_Call struct {
	*mock.Call
}

// UnsignedBigInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) UnsignedBigInteger(column interface{}) *Blueprint_UnsignedBigInteger_Call {
	return &Blueprint_UnsignedBigInteger_Call{Call: _e.mock.On("UnsignedBigInteger", column)}
}

func (_c *Blueprint_UnsignedBigInteger_Call) Run(run func(column string)) *Blueprint_UnsignedBigInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_UnsignedBigInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_UnsignedBigInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedBigInteger_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_UnsignedBigInteger_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedInteger provides a mock function with given fields: column
func (_m *Blueprint) UnsignedInteger(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedInteger'
type Blueprint_UnsignedInteger_Call struct {
	*mock.Call
}

// UnsignedInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) UnsignedInteger(column interface{}) *Blueprint_UnsignedInteger_Call {
	return &Blueprint_UnsignedInteger_Call{Call: _e.mock.On("UnsignedInteger", column)}
}

func (_c *Blueprint_UnsignedInteger_Call) Run(run func(column string)) *Blueprint_UnsignedInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_UnsignedInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_UnsignedInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedInteger_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_UnsignedInteger_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedMediumInteger provides a mock function with given fields: column
func (_m *Blueprint) UnsignedMediumInteger(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedMediumInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedMediumInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedMediumInteger'
type Blueprint_UnsignedMediumInteger_Call struct {
	*mock.Call
}

// UnsignedMediumInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) UnsignedMediumInteger(column interface{}) *Blueprint_UnsignedMediumInteger_Call {
	return &Blueprint_UnsignedMediumInteger_Call{Call: _e.mock.On("UnsignedMediumInteger", column)}
}

func (_c *Blueprint_UnsignedMediumInteger_Call) Run(run func(column string)) *Blueprint_UnsignedMediumInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_UnsignedMediumInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_UnsignedMediumInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedMediumInteger_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_UnsignedMediumInteger_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedSmallInteger provides a mock function with given fields: column
func (_m *Blueprint) UnsignedSmallInteger(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedSmallInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedSmallInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedSmallInteger'
type Blueprint_UnsignedSmallInteger_Call struct {
	*mock.Call
}

// UnsignedSmallInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) UnsignedSmallInteger(column interface{}) *Blueprint_UnsignedSmallInteger_Call {
	return &Blueprint_UnsignedSmallInteger_Call{Call: _e.mock.On("UnsignedSmallInteger", column)}
}

func (_c *Blueprint_UnsignedSmallInteger_Call) Run(run func(column string)) *Blueprint_UnsignedSmallInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_UnsignedSmallInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_UnsignedSmallInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedSmallInteger_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_UnsignedSmallInteger_Call {
	_c.Call.Return(run)
	return _c
}

// UnsignedTinyInteger provides a mock function with given fields: column
func (_m *Blueprint) UnsignedTinyInteger(column string) schema.ColumnDefinition {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for UnsignedTinyInteger")
	}

	var r0 schema.ColumnDefinition
	if rf, ok := ret.Get(0).(func(string) schema.ColumnDefinition); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(schema.ColumnDefinition)
		}
	}

	return r0
}

// Blueprint_UnsignedTinyInteger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsignedTinyInteger'
type Blueprint_UnsignedTinyInteger_Call struct {
	*mock.Call
}

// UnsignedTinyInteger is a helper method to define mock.On call
//   - column string
func (_e *Blueprint_Expecter) UnsignedTinyInteger(column interface{}) *Blueprint_UnsignedTinyInteger_Call {
	return &Blueprint_UnsignedTinyInteger_Call{Call: _e.mock.On("UnsignedTinyInteger", column)}
}

func (_c *Blueprint_UnsignedTinyInteger_Call) Run(run func(column string)) *Blueprint_UnsignedTinyInteger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Blueprint_UnsignedTinyInteger_Call) Return(_a0 schema.ColumnDefinition) *Blueprint_UnsignedTinyInteger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Blueprint_UnsignedTinyInteger_Call) RunAndReturn(run func(string) schema.ColumnDefinition) *Blueprint_UnsignedTinyInteger_Call {
	_c.Call.Return(run)
	return _c
}

// NewBlueprint creates a new instance of Blueprint. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBlueprint(t interface {
	mock.TestingT
	Cleanup(func())
}) *Blueprint {
	mock := &Blueprint{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
